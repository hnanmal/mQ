1. 입도(入道)의 문
├── 1.1 코딩이란 무엇인가?
│   ├── 1.1.1 코드와 세계를 연결하는 언어
│   ├── 1.1.2 기계가 아닌 나를 위한 문법
│   └── 1.1.3 개념과 구현 사이의 간극
├── 1.2 왜 오행으로 프로그래밍을 보는가?
│   ├── 1.2.1 서양의 분할, 동양의 순환
│   ├── 1.2.2 오행이 설명하는 구조와 변화
│   └── 1.2.3 ‘이해’를 넘어 ‘체화’로 가는 길
└── 1.3 오행입도경의 읽는 방법
    ├── 1.3.1 처음 입문하는 이에게
    ├── 1.3.2 이미 길을 걷고 있는 이에게
    └── 1.3.3 길을 벗어나 다시 돌아온 이에게

2. 목(木) — 생성과 구조
├── 2.1 데이터의 씨앗: 변수와 상수
│   ├── 2.1.1 변수는 왜 생기는가?
│   ├── 2.1.2 상수는 고정인가 중심인가?
│   └── 2.1.3 선언의 의식, 명명과 책임
├── 2.2 뿌리 내리는 구조: 자료구조의 이해
│   ├── 2.2.1 리스트와 배열의 직선적 사고
│   ├── 2.2.2 트리와 그래프의 확장적 사고
│   └── 2.2.3 구조를 선택하는 기준
├── 2.3 나무처럼 확장되는 참조와 연결
│   ├── 2.3.1 포인터와 레퍼런스의 개념
│   ├── 2.3.2 연결 리스트와 노드 사고
│   └── 2.3.3 의존성과 순환의 문제
├── 2.4 객체지향의 시작: 구성과 조립
│   ├── 2.4.1 클래스란 무엇인가
│   ├── 2.4.2 생성자와 초기화 의식
│   └── 2.4.3 상속과 구성의 균형
└── 2.5 목적 사고의 수련
    ├── 2.5.1 나무를 그리는 설계 마인드
    ├── 2.5.2 지나친 가지치기의 위험
    └── 2.5.3 성장하는 코드를 위하여

3. 화(火) — 흐름과 분기
├── 3.1 조건문: 갈래지는 불길
│   ├── 3.1.1 if-else와 선택의 철학
│   ├── 3.1.2 switch-case와 명확한 구분
│   └── 3.1.3 조건 중첩의 위험과 해법
├── 3.2 반복문: 불꽃의 순환
│   ├── 3.2.1 for와 while의 차이
│   ├── 3.2.2 break와 continue의 역할
│   └── 3.2.3 무한 루프의 존재론
├── 3.3 흐름 제어의 기술
│   ├── 3.3.1 흐름 제어문 종류와 역할
│   ├── 3.3.2 try-catch: 불을 제어하는 도구
│   └── 3.3.3 흐름 제어와 예외 처리의 경계
├── 3.4 병렬성과 비동기: 억제된 화
│   ├── 3.4.1 동시성과 병렬성의 차이
│   ├── 3.4.2 콜백과 프라미스의 흐름
│   └── 3.4.3 async/await의 명상적 구조
└── 3.5 화의 수련
    ├── 3.5.1 코드 흐름의 시각화 훈련
    ├── 3.5.2 디버깅과 흐름 추적
    └── 3.5.3 ‘제어’ 아닌 ‘유도’로의 사고 전환

4. 토(土) — 중심과 안정
├── 4.1 함수: 축적되고 반복되는 땅
│   ├── 4.1.1 함수의 정의와 목적
│   ├── 4.1.2 입력과 출력: 흙의 순환
│   └── 4.1.3 순수 함수와 부작용
├── 4.2 예외 처리: 혼돈 속의 질서
│   ├── 4.2.1 try-catch-finally의 조화
│   ├── 4.2.2 사용자 정의 예외
│   └── 4.2.3 예외가 의미하는 것
├── 4.3 모듈화와 재사용: 축조의 미학
│   ├── 4.3.1 함수에서 모듈로
│   ├── 4.3.2 모듈의 책임 분리
│   └── 4.3.3 디렉터리 구조와 도식화
├── 4.4 테스트: 흔들리지 않는 구조 만들기
│   ├── 4.4.1 단위 테스트란 무엇인가
│   ├── 4.4.2 테스트 주도 개발(TDD)
│   └── 4.4.3 실패를 받아들이는 토의 자세
└── 4.5 토의 수련
    ├── 4.5.1 작은 단위로 나누기
    ├── 4.5.2 실패에서 배우기
    └── 4.5.3 코드를 ‘짓는다’는 태도

5. 금(金) — 추상화와 도구
├── 5.1 클래스와 인터페이스: 단단한 틀
│   ├── 5.1.1 클래스의 역할과 존재 이유
│   ├── 5.1.2 인터페이스와 다형성
│   └── 5.1.3 추상 클래스와 구체 클래스
├── 5.2 디자인 패턴: 금형의 사고
│   ├── 5.2.1 싱글톤, 팩토리, 옵저버의 정신
│   ├── 5.2.2 SOLID 원칙의 내면화
│   └── 5.2.3 구조적 패턴과 설계 감각
├── 5.3 자동화 도구와 빌드 시스템
│   ├── 5.3.1 빌드란 무엇인가?
│   ├── 5.3.2 의존성 관리와 패키징
│   └── 5.3.3 자동화의 위험과 절제
├── 5.4 성능 최적화: 날카로운 연마
│   ├── 5.4.1 시간 복잡도와 공간 복잡도
│   ├── 5.4.2 병목 지점 찾기
│   └── 5.4.3 리팩토링의 타이밍
└── 5.5 금의 수련
    ├── 5.5.1 코드를 간결하게 만드는 법
    ├── 5.5.2 도구에 끌려가지 않기
    └── 5.5.3 깊이를 더하는 반복 수련

6. 수(水) — 유연성과 흐름
├── 6.1 함수형 프로그래밍: 흐름의 미학
│   ├── 6.1.1 순수 함수와 불변성
│   ├── 6.1.2 고차 함수와 합성
│   └── 6.1.3 map, filter, reduce의 철학
├── 6.2 상태 관리: 물의 기억
│   ├── 6.2.1 상태란 무엇인가?
│   ├── 6.2.2 로컬, 글로벌, 공유 상태
│   └── 6.2.3 흐름 속 상태의 동기화
├── 6.3 디버깅과 로깅: 투명한 수면
│   ├── 6.3.1 로그는 나의 발자국
│   ├── 6.3.2 디버깅의 전략과 습관
│   └── 6.3.3 버그를 ‘이해’하는 법
├── 6.4 사용자와의 인터랙션
│   ├── 6.4.1 입력 → 처리 → 출력의 리듬
│   ├── 6.4.2 UI 흐름 설계의 감성
│   └── 6.4.3 이벤트와 반응형 사고
└── 6.5 수의 수련
    ├── 6.5.1 코드를 흐르게 하는 마음
    ├── 6.5.2 다름을 수용하는 유연함
    └── 6.5.3 연결을 통해 배우는 겸허함

7. 오행합일 — 도의 구현
├── 7.1 오행의 상호작용
│   ├── 7.1.1 생성(相生)과 극(相剋)의 프로그래밍
│   ├── 7.1.2 목 → 화 → 토 → 금 → 수 순환
│   └── 7.1.3 모순을 통합하는 시선
├── 7.2 조화로운 시스템 설계
│   ├── 7.2.1 오행적 시선으로 구조 바라보기
│   ├── 7.2.2 설계 초안에서 느끼는 균형
│   └── 7.2.3 지속 가능한 코드베이스란?
├── 7.3 프로젝트 수행의 단계별 순환
│   ├── 7.3.1 시작의 목(木), 타오름의 화(火)
│   ├── 7.3.2 안정의 토(土), 구조화의 금(金)
│   └── 7.3.3 수(水)처럼 흘러 완성에 이르다
├── 7.4 마스터리란 무엇인가
│   ├── 7.4.1 실력과 깊이의 차이
│   ├── 7.4.2 ‘잘 짜는 사람’의 조건
│   └── 7.4.3 끊임없는 도의 추구
└── 7.5 도를 걷는 개발자란 누구인가
    ├── 7.5.1 기술보다 중요한 태도
    ├── 7.5.2 자신만의 리듬과 도형(道型)
    └── 7.5.3 함께 걷는 길, 후학을 위한 지도


